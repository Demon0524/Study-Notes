#Learning  #DevOps #Docker
# docket镜像、分层原理

```bash
# 容器层，可修改。重启容器后生效
具体的程序运行---可以写入的容器
--------------------
# 以下为只读，不能修改
依赖环境2---其他镜像
依赖环境1---其他镜像，如JDK
docker获取基础就镜像---rootfs，早bootfs之上，包含典型linux系统中的/dev、/proc、/bin、/etc等标准目录和文件；rootfs就是各种不同操作系统的发行版，比如ubantu、centos
宿主机提供linux内核---bootfs主要包含bootloader和kernal；bootloader主要是引导加载kernal，linux刚启动时会加载bootfs文件系统
```

> docker通过 union file system，将上述不同的每一层，整合为一个文件系统，为用户隐藏了多层的视角
```perl
# 在使用基础组件生成容器的时候，实际上还是会有底层的rootfs，在此之上才能运行相应的组件
# 查看nginx容器的操作系统
docker ps -a
docker exec -it fdc889b3f706 bash

[node2@Serverb ~]$ docker ps -a
CONTAINER ID   IMAGE     COMMAND                   CREATED          STATUS                      PORTS     NAMES
fdc889b3f706   nginx     "/docker-entrypoint.…"   12 hours ago     Exited (0) 9 hours ago                keen_feynman
[node2@Serverb ~]$ docker exec -it fdc889b3f706 bash
root@fdc889b3f706:/# cat /etc/os-release 
NAME="Debian GNU/Linux"
VERSION_ID="11"
VERSION="11 (bullseye)"
VERSION_CODENAME=bullseye
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

```

自定义镜像步骤：
- docker镜像不包含linux kernal，需要与宿主机共用linux kernal
- 获取基础镜像，选择一个发行平台（ubantu、centos）
- 在centos镜像中安装mysql5.6软甲
导出镜像，可以命名为mysql:5.6软件

![[../../../A-Accessories-Note附件/Pasted image 20240517224315.png]]
从这个过程中可以了解到这是一层一层的添加，codker镜像的层级概念就出来了，底层是centos镜像，上层是mysql镜像，**centos镜像层属于父镜像**
## Docker为什么分层镜像
镜像分享一大好处就是共享资源，例如有多个镜像都来自base镜像，那么在docker host只需要存储一份base镜像

内存里也只需要加载一份host，即可为多个容器服务

即使多个容器共享一个base镜像，某个容器修改了base镜像的内容，其他容器下的内容是不会修改的，修改动作只限制在单个容器内，这就是**容器的写时复制特性（copy-on-write）**

### 可写的容器层
当容器启动后，一个新的可写层被加载到镜像的顶部，这一层通常被称为`容器层`，`容器层`下的都被成为`镜像层`
对容器的修改动作只会发生在 `容器层` ，只有 `容器层` 是可写的，其余 `镜像层` 都是只读的

| 文件操作 |                                  说明                                  |
| :--: | :------------------------------------------------------------------: |
| 添加文件 |                        在容器中创建文件时，新文件被添加到容器层中。                        |
| 读取文件 |   在同其中读取某一个文件时，Docker会从上往下依次在各镜像层中查找文件。一旦找到，立即将其复制到容器层中，然后打开并读入内存    |
| 修改文件 |     在容器中修改已存在的文件时，Docker会从上往下依次在各镜像层中查找此文件。一旦找到，立刻将其复制到容器层，然后修改      |
| 删除文件 | 在容器中删除文件时，Docker也会从上往下依次在各镜像层中查找此文件。找到后，会在容器层中==**记录下此删除操作**（只是记录）== |

只有当需要修改时才复制一份数据，这种特性被称为 `Copy-on-Write` 。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。
这样就解释了之前的问题：容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享。

### Docker镜像的内容
docker镜像层级管理的方式大大便捷了Docker镜像的分发和存储。
- Docker镜像代表一个容器的文件系统内容
- 镜像层级技术属于 `联合文件系统` 
- 容器是一个动态的环境，每一层镜像里的文件都属于静态内容
	- dockerfile里的ENV、VOLUME、CMD等内容都会落实到容器环境里


### UnionFS 图解
![[../../../A-Accessories-Note附件/Pasted image 20240517235002.png]]


## 小节
1. 当通过一个image启动容器时，docker会在改image最顶层，添加一个读写文件系统作为容器，然后 运行该容器。
2. docker镜像本质时基于UunionFS管理的分层文件系统
3. docker镜像为什么才几百兆？
答：因为docker镜像是由rootfs和其他镜像层，共用宿主机的linux kernal（bootfs），因此很小
4. 为什么下载一个docker的nginx镜像需要133M，nginx安装包才十几兆
答：因为docker的nginx镜像是分层的；运行一个nginx的镜像文件，依赖于父镜像（上一层）和基础镜像（发行版），所以需要几百兆